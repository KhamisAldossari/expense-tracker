I have a problem in my calling services like fetchExpenses beacause the bakend need auth token.
fix the code and highlight the changes.
follow the folloing:
- use zustand for state 
- write clean reusble code 
- write logs and handle exiptions 


//src/components/auth/Login.tsx
import { useState, useEffect } from "react";
import { loginService } from "@/services/authService";
import { useNavigate } from "react-router-dom";
import useAuthStore from "@/stores/authStore";
import { User, Lock, AlertCircle } from 'lucide-react';

const Login: React.FC = () => {
  const [credentials, setCredentials] = useState({ email: "", password: "" });
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();
  const token = useAuthStore((state) => state.token);




  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setCredentials({ ...credentials, [name]: value });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const response = await loginService(credentials.email, credentials.password);
      useEffect(() => {
        if (token && response.success) {
          console.log("Stored token:", token);
          navigate("/expenses");

        } else {
          setError(response.message);
        }
      }, [token]);
      
    } catch (err) {
      setError("An unexpected error occurred. Please try again.");
    }
  };

  return (
    <div className="login-container">
      <form onSubmit={handleSubmit} className="login-form">
        <div className="input-group">
          <User className="icon" />
          <input
            type="text"
            name="email"
            value={credentials.email}
            onChange={handleChange}
            placeholder="Email"
            required
          />
        </div>
        <div className="input-group">
          <Lock className="icon" />
          <input
            type="password"
            name="password"
            value={credentials.password}
            onChange={handleChange}
            placeholder="Password"
            required
          />
        </div>
        {error && (
          <div className="error-message">
            <AlertCircle className="icon" />
            {error}
          </div>
        )}
        <button type="submit" className="login-button">Login</button>
        <button type="button" className="signup-button" onClick={() => navigate("/signup")}>Sign Up</button>
      </form>
    </div>
  );
};

export default Login;


//src/components/auth/SignUp.tsx
import { useState } from "react";
import { signUpService } from "@/services/authService";
import { useNavigate } from "react-router-dom";

const SignUp: React.FC = () => {
  const [formData, setFormData] = useState({
    username: "",
    email: "",
    password: "",
  });
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const navigate = useNavigate();

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const response = await signUpService(formData.username, formData.email, formData.password);
      if (response.success) {
        setSuccessMessage("Sign up successful! Redirecting to login...");
        setTimeout(() => navigate("/"), 3000); // Redirect after 3 seconds
      } else {
        setError(response.message);
      }
    } catch (err) {
      setError("An unexpected error occurred. Please try again.");
    }
  };

  return (
    <div style={{ maxWidth: "400px", margin: "auto", padding: "20px" }}>
      <h2>Sign Up</h2>
      {error && <p style={{ color: "red" }}>{error}</p>}
      {successMessage && <p style={{ color: "green" }}>{successMessage}</p>}
      <form onSubmit={handleSubmit}>
        <div>
          <label>Username</label>
          <input
            type="text"
            name="username"
            value={formData.username}
            onChange={handleChange}
            required
          />
        </div>
        <div>
          <label>Email</label>
          <input
            type="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            required
          />
        </div>
        <div>
          <label>Password</label>
          <input
            type="password"
            name="password"
            value={formData.password}
            onChange={handleChange}
            required
          />
        </div>
        <button type="submit">Sign Up</button>
      </form>
      <p>
        Already have an account?{" "}
        <span onClick={() => navigate("/")} style={{ color: "blue", cursor: "pointer" }}>
          Log In
        </span>
      </p>
    </div>
  );
};

export default SignUp;


//src/components/expenses/ExpensesTracker.tsx
"use client"

import { useState } from 'react'
import { ExpenseDashboard } from './ExpenseDashboard'
import { ExpenseFilters } from './ExpenseFilters'
import { ExpenseList } from './ExpenseList'
import { AddExpenseDialog } from './AddExpenseDialog'
import { UpdateExpenseDialog } from './UpdateExpenseDialog'
import { useExpenses } from '@/stores/useExpenses'
import { Expense } from '@/types/expense'

export default function ExpenseTracker() {
  const {
    expenses,
    categories,
    addExpense,
    updateExpense,
    deleteExpense,
    totalSpend,
    searchTerm,
    setSearchTerm,
    categoryFilter,
    setCategoryFilter,
    sortBy,
    setSortBy,
    sortOrder,
    setSortOrder,
    isLoading,  
    error
    
  } = useExpenses()

  const [isAddExpenseOpen, setIsAddExpenseOpen] = useState(false)
  const [isUpdateExpenseOpen, setIsUpdateExpenseOpen] = useState(false)
  const [currentExpense, setCurrentExpense] = useState<Expense | null>(null)

  const handleUpdate = (expense: Expense) => {
    setCurrentExpense(expense)
    setIsUpdateExpenseOpen(true)
  }

  if (isLoading) {
    return <div className="container mx-auto p-4">Loading expenses...</div>
  }

  if (error) {
    return <div className="container mx-auto p-4 text-red-500">Error: {error}</div>
  }

  return (
    <div className="container mx-auto p-4">
      <ExpenseDashboard totalSpend={totalSpend} />

      <ExpenseFilters
        searchTerm={searchTerm}
        setSearchTerm={setSearchTerm}
        categoryFilter={categoryFilter}
        setCategoryFilter={setCategoryFilter}
        sortBy={sortBy}
        setSortBy={setSortBy}
        sortOrder={sortOrder}
        setSortOrder={setSortOrder}
        setIsAddExpenseOpen={setIsAddExpenseOpen}
        categories={categories}
      />

      <ExpenseList
        expenses={expenses}
        onUpdate={handleUpdate}
        onDelete={deleteExpense}
      />

      <AddExpenseDialog
        isOpen={isAddExpenseOpen}
        onOpenChange={setIsAddExpenseOpen}
        onAddExpense={addExpense}
        categories={categories} 
      />

      <UpdateExpenseDialog
        isOpen={isUpdateExpenseOpen}
        onOpenChange={setIsUpdateExpenseOpen}
        expense={currentExpense}
        onUpdateExpense={updateExpense}
        categories={categories} 
      />
    </div>
  )
}

//src/lib/utils.ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



//src/services/authService.ts
import axios from "axios";

const LOGIN_API_URL = "http://localhost:8000/api/login"; // Replace with your login API endpoint
const SIGNUP_API_URL = "http://localhost:8000/api/register"; // Replace with your sign-up API endpoint

export const loginService = async (email: string, password: string) => {
  try {
    const response = await axios.post(LOGIN_API_URL, { email, password });
    return { success: true, data: response.data }; // Adjust the data structure as per your API response
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      return { success: false, message: error.response.data.message || "Login failed" };
    }
    return { success: false, message: "Network error" };
  }
};

export const signUpService = async (username: string, email: string, password: string) => {
  try {
    const response = await axios.post(SIGNUP_API_URL, { username, email, password });
    return { success: true, data: response.data }; // Adjust the data structure as per your API response
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      return { success: false, message: error.response.data.message || "Sign up failed" };
    }
    return { success: false, message: "Network error" };
  }
};


//src/services/expensesService.ts
import { Expense } from '@/types/expense';
import { mockExpenseService, mockCategoriesService } from './mockExpenseService';
import { useEffect } from 'react';
// Flag to switch between mock and real services
const USE_MOCK = false ;

export const expenseService = USE_MOCK ? mockExpenseService : {
  async getExpenses(token: string): Promise<Expense[]> {
    const response = await fetch('http://localhost:8000/api/expenses', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
    if (!response.ok) throw new Error('Failed to fetch expenses');
    return response.json();
  },


  async addExpense(expense: Omit<Expense, 'id'>): Promise<Expense> {
    const response = await fetch('http://localhost:8000/api/expenses', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(expense),
    });
    if (!response.ok) throw new Error('Failed to add expense');
    return response.json();
  },

  async updateExpense(id: number, expense: Partial<Expense>): Promise<Expense> {
    const response = await fetch(`http://localhost:8000/api/expenses/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(expense),
    });
    if (!response.ok) throw new Error('Failed to update expense');
    return response.json();
  },

  async deleteExpense(id: number): Promise<void> {
    const response = await fetch(`http://localhost:8000/api/expenses/${id}`, { 
      method: 'DELETE' 
    });
    if (!response.ok) throw new Error('Failed to delete expense');
  }
};

export const categoriesService = USE_MOCK ? mockCategoriesService : {
  async getCategories(): Promise<string[]> {
    const response = await fetch('http://localhost:8000/api/categories');
    if (!response.ok) throw new Error('Failed to fetch categories');
    return response.json();
  }
};


//src/stores/authStore.ts
import { create } from "zustand";

interface User {
  username?: string;
  email: string; 
}

interface AuthState {
  email: User | null;
  token: string | null;
  setEmail: (email: User) => void;
  setToken: (token: string) => void;
  logout: () => void;
}

const useAuthStore = create<AuthState>((set) => ({
  email: null,
  token: null,
  setEmail: (email) => set({ email }),
  setToken: (token) => set({ token }),
  logout: () => set({ email: null, token: null }),
}));

export default useAuthStore;



//src/stores/useExpenses.ts
import { useState, useMemo, useEffect } from 'react'
import { useExpenseStore } from '@/stores/useExpenseStore'
import { Expense } from '@/types/expense'

export function useExpenses() {
  const {
    expenses,
    categories,
    addExpense: storeAddExpense,
    updateExpense: storeUpdateExpense,
    deleteExpense: storeDeleteExpense,
    fetchExpenses,
    fetchCategories,
    token,
    isLoading,
    error
  } = useExpenseStore()

  const [searchTerm, setSearchTerm] = useState('')
  const [categoryFilter, setCategoryFilter] = useState('all')
  const [sortBy, setSortBy] = useState<'date' | 'amount'>('date')
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc')

  useEffect(() => {
    fetchExpenses()
    fetchCategories()
    
  }, [fetchExpenses, fetchCategories])

  const addExpense = async (newExpense: Omit<Expense, 'id'>) => {
    await storeAddExpense(newExpense)
  }

  const updateExpense = async (updatedExpense: Expense) => {
    await storeUpdateExpense(updatedExpense.id, updatedExpense)
  }

  const deleteExpense = async (id: number) => {
    await storeDeleteExpense(id)
  }

  const filteredAndSortedExpenses = useMemo(() => {
    return [...expenses]
      .filter(expense =>
        (expense.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
         expense.category.toLowerCase().includes(searchTerm.toLowerCase())) &&
        (categoryFilter === 'all' || expense.category === categoryFilter)
      )
      .sort((a, b) => {
        if (sortBy === 'date') {
          return sortOrder === 'asc' 
            ? new Date(a.date).getTime() - new Date(b.date).getTime()
            : new Date(b.date).getTime() - new Date(a.date).getTime()
        } else {
          return sortOrder === 'asc' ? a.amount - b.amount : b.amount - a.amount
        }
      })
  }, [expenses, searchTerm, categoryFilter, sortBy, sortOrder])

  const totalSpend = useMemo(() => {
    return filteredAndSortedExpenses.reduce((sum, expense) => sum + expense.amount, 0)
  }, [filteredAndSortedExpenses])

  return {
    expenses: filteredAndSortedExpenses,
    categories,
    addExpense,
    updateExpense,
    deleteExpense,
    totalSpend,
    searchTerm,
    setSearchTerm,
    categoryFilter,
    setCategoryFilter,
    sortBy,
    setSortBy,
    sortOrder,
    setSortOrder,
    isLoading,
    error
  }
}

//src/stores/useExpensesStore.ts
import { create } from 'zustand';
import { categoriesService, expenseService } from '../services/expenseService';
import { ExpenseStore } from '../types/expenseStore';

export const useExpenseStore = create<ExpenseStore>((set, get) => ({
  expenses: [],
  categories: [],
  filters: {
    category: 'all',
    searchTerm: '',
  },
  isLoading: false,
  error: null,
  editingExpense: null,
  token: '',

  setToken: (token: string) => {
    set({ token });
  },

 fetchExpenses: async () => {
    set({ isLoading: true, error: null });
    const token = get().token;  
    try {
      const expenses = await expenseService.getExpenses(token);
      set({ expenses, isLoading: false });
    } catch (error) {
      set({ error: 'Failed to fetch expenses', isLoading: false });
    }
  },
  
  fetchCategories: async () => {
    set({ isLoading: true, error: null });
    try {
      const categories = await categoriesService.getCategories();
      set({ categories, isLoading: false });
    } catch (error) {
      set({ error: 'Failed to fetch categories', isLoading: false });
    }
  },

  addExpense: async (expense) => {
    set({ isLoading: true, error: null });
    try {
      const newExpense = await expenseService.addExpense(expense);
      set(state => ({
        expenses: [newExpense, ...state.expenses],
        isLoading: false
      }));
    } catch (error) {
      set({ error: 'Failed to add expense', isLoading: false });
    }
  },

  updateExpense: async (id, expense) => {
    set({ isLoading: true, error: null });
    try {
      const updatedExpense = await expenseService.updateExpense(id, expense);
      set(state => ({
        expenses: state.expenses.map(e => e.id === id ? updatedExpense : e),
        editingExpense: null,
        isLoading: false
      }));
    } catch (error) {
      set({ error: 'Failed to update expense', isLoading: false });
    }
  },

  deleteExpense: async (id) => {
    set({ isLoading: true, error: null });
    try {
      await expenseService.deleteExpense(id);
      set(state => ({
        expenses: state.expenses.filter(e => e.id !== id),
        isLoading: false
      }));
    } catch (error) {
      set({ error: 'Failed to delete expense', isLoading: false });
    }
  },

  setEditingExpense: (expense) => {
    set({ editingExpense: expense });
  },

  setFilters: (newFilters) => {
    set(state => ({
      filters: { ...state.filters, ...newFilters }
    }));
  },

  clearError: () => {
    set({ error: null });
  },

  getFilteredExpenses: () => {
    const { expenses, filters } = get();
    return expenses.filter(expense => {
      const matchesCategory = filters.category === 'all' || 
                            expense.category === filters.category;
      const matchesSearch = expense.description
        .toLowerCase()
        .includes(filters.searchTerm.toLowerCase());
      return matchesCategory && matchesSearch;
    });
  },

  getTotalExpenses: () => {
    return get().expenses.reduce((sum, exp) => sum + exp.amount, 0);
  },

}));


//src/types/expense.ts
export interface Expense {
  id: number
  description: string
  category: string
  amount: number
  date: string
}

//src/types/expenseFilters.ts
export interface ExpenseFilters {
    category: string
    searchTerm: string
  }

//src/types/expenseStore.ts
import { Expense } from '../types/expense';
import { ExpenseFilters } from '../types/expenseFilters';

export interface ExpenseStore {
    // State
    expenses: Expense[];
    categories: string[];
    filters: ExpenseFilters;
    isLoading: boolean;
    error: string | null;
    editingExpense: Expense | null;
    token: string;
  

    // Fetch Actions
    fetchExpenses: () => Promise<void>;
    fetchCategories: () => Promise<void>;

    // CRUD Actions
    addExpense: (expense: Omit<Expense, 'id'>) => Promise<void>;
    updateExpense: (id: number, expense: Partial<Expense>) => Promise<void>;
    deleteExpense: (id: number) => Promise<void>;
    
    // UI Actions
    setEditingExpense: (expense: Expense | null) => void;
    setFilters: (filters: Partial<ExpenseFilters>) => void;
    clearError: () => void;
  
    // Computed
    getFilteredExpenses: () => Expense[];
    getTotalExpenses: () => number;
    // getMonthlyExpenses: () => number;
  }

